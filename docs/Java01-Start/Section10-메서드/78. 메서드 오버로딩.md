# 메서드 오버로딩

## 1. 메서드 오버로딩이란?

다음과 같은 메서드를 만들고 싶다고 하자.

* 두 수를 더하는 메서드
* 세 수를 더하는 메서드

이 경우, 둘 다 “더하는 메서드”이기 때문에 **가급적 같은 이름인 `add`** 를 사용하고 싶다.

자바는 메서드를 구분할 때 **메서드 이름뿐만 아니라 매개변수 정보도 함께 사용**한다.
따라서 다음과 같이 **이름이 같고, 매개변수가 다른 메서드**를 정의할 수 있다.

### 오버로딩 성공 예시

```java
add(int a, int b)
add(int a, int b, int c)
add(double a, double b)
```

이렇게 **이름이 같고 매개변수가 다른 메서드를 여러 개 정의하는 것**을
**메서드 오버로딩(Method Overloading)** 이라고 한다.

> 오버로딩(overloading)은 번역하면 **과적**인데,
> “과하게 물건을 담았다”는 뜻이다.
> 여기서는 **같은 이름의 메서드를 여러 개 정의했다**고 이해하면 된다.

---

## 2. 오버로딩 규칙

* **메서드 이름이 같아도**,
  **매개변수의 타입 및 순서가 다르면** 오버로딩을 할 수 있다.
* 참고로 **반환 타입만 다른 경우는 오버로딩으로 인정하지 않는다.**

### 오버로딩 실패 예시

다음 케이스는 **메서드 이름과 매개변수의 타입이 같으므로** 컴파일 오류가 발생한다.
반환 타입만 다르기 때문에 오버로딩으로 인정되지 않는다.

```java
int add(int a, int b)
double add(int a, int b)
```

---

## 3. 용어: 메서드 시그니처 (method signature)

> **메서드 시그니처 = 메서드 이름 + 매개변수 타입(순서 포함)**

* 메서드 시그니처는 자바에서 메서드를 구분할 수 있는 **고유한 식별자(서명)** 를 뜻한다.
* 메서드 시그니처는

    * **메서드 이름**
    * **매개변수 타입 (순서 포함)**
      로 구성되어 있다.
* 쉽게 이야기해서 **메서드를 구분할 수 있는 기준**이다.

자바 입장에서는 각각의 메서드를 **고유하게 구분할 수 있어야 한다.**
그래야 **어떤 메서드를 호출할지 결정**할 수 있다.

따라서, 메서드 오버로딩에서 설명한 것처럼

* **메서드 이름이 같아도**
* **메서드 시그니처가 다르면**

서로 **다른 메서드**로 간주한다.

> **반환 타입은 시그니처에 포함되지 않는다.**

앞에서 본 오버로딩 실패 예제를 다시 보자.

```java
int add(int a, int b)
double add(int a, int b)
```

* 두 메서드는 모두 `add(int a, int b)` 라는 **같은 메서드 시그니처**를 가진다.
* 따라서 메서드를 구분할 수 없으므로 **컴파일 오류**가 발생한다.

---

## 4. 예제 1 – 매개변수의 개수가 다른 오버로딩 (`Overloading1`)

먼저 **매개변수의 개수**가 다른 오버로딩 예제를 보자.

### `Overloading1` 코드

```java
package overloading;

public class Overloading1 {

    public static void main(String[] args) {
        System.out.println("1: " + add(1, 2));
        System.out.println("2: " + add(1, 2, 3));
    }

    // 첫 번째 add 메서드: 두 정수를 받아서 합을 반환한다.
    public static int add(int a, int b) {
        System.out.println("1번 호출");
        return a + b;
    }

    // 두 번째 add 메서드: 세 정수를 받아서 합을 반환한다.
    // 첫 번째 메서드와 이름은 같지만, 매개변수 목록이 다르다.
    public static int add(int a, int b, int c) {
        System.out.println("2번 호출");
        return a + b + c;
    }
}
```

호출 흐름은 다음과 같다.

* `1: " + add(1, 2)`
  → 정수 `1`, `2`를 넘겼으므로 `add(int a, int b)` 가 호출된다.
* `2: " + add(1, 2, 3)`
  → 정수 `1`, `2`, `3`을 넘겼으므로 `add(int a, int b, int c)` 가 호출된다.

### 실행 결과

```text
1번 호출
1: 3
2번 호출
2: 6
```

---

## 5. 예제 2 – 매개변수의 타입과 순서가 다른 오버로딩 (`Overloading2`)

이번에는 **매개변수의 타입과 순서가 다른** 오버로딩 예제를 보자.

### `Overloading2` 코드

```java
package overloading;

public class Overloading2 {

    public static void main(String[] args) {
        myMethod(1, 1.2);
        myMethod(1.2, 2);
    }

    public static void myMethod(int a, double b) {
        System.out.println("int a, double b");
    }

    public static void myMethod(double a, int b) {
        System.out.println("double a, int b");
    }
}
```

호출 흐름은 다음과 같다.

1. `myMethod(1, 1.2);`
   → 정수 `1`, 실수 `1.2`를 넘겼으므로
   `myMethod(int a, double b)` 가 호출된다.
2. `myMethod(1.2, 2);`
   → 실수 `1.2`, 정수 `2`를 넘겼으므로
   `myMethod(double a, int b)` 가 호출된다.

### 실행 결과

```text
int a, double b
double a, int b
```

---

## 6. 예제 3 – 매개변수의 타입이 다른 오버로딩 (`Overloading3`)

마지막으로 **매개변수의 타입이 다른 경우**를 추가로 확인해 보자.

### `Overloading3` 코드

```java
package overloading;

public class Overloading3 {

    public static void main(String[] args) {
        System.out.println("1: " + add(1, 2));
        System.out.println("2: " + add(1.2, 1.5));
    }

    // 첫 번째 add 메서드: 두 정수를 받아서 합을 반환한다.
    public static int add(int a, int b) {
        System.out.println("1번 호출");
        return a + b;
    }

    // 두 번째 add 메서드: 두 실수를 받아서 합을 반환한다.
    // 첫 번째 메서드와 이름은 같지만, 매개변수의 유형이 다르다.
    public static double add(double a, double b) {
        System.out.println("2번 호출");
        return a + b;
    }
}
```

호출 흐름은 다음과 같다.

1. `"1: " + add(1, 2)`
   → 정수 `1`, 정수 `2`를 넘겼으므로
   `add(int a, int b)` 가 호출된다.
2. `"2: " + add(1.2, 1.5)`
   → 실수 `1.2`, 실수 `1.5`를 넘겼으므로
   `add(double a, double b)` 가 호출된다.

### 실행 결과

```text
1번 호출
1: 3
2번 호출
2: 2.7
```

---

## 7. `int` 버전 메서드를 삭제했을 때의 동작

여기서 만약 다음 **첫 번째 메서드**를 삭제하면 어떻게 될까?

```java
public static int add(int a, int b) {
    System.out.println("1번 호출");
    return a + b;
}
```

이 경우 호출 흐름은 다음과 같이 바뀐다.

1. `add(1, 2)`
   → `int` 형 정수 `1`, `2`를 넘겼지만,
   이제 `add(int a, int b)` 가 없으므로
   **자동 형변환**이 발생해서 `add(double a, double b)` 가 호출된다.
2. `add(1.2, 1.5)`
   → 원래대로 `add(double a, double b)` 가 호출된다.

### 실행 결과

```text
2번 호출
1: 3.0
2번 호출
2: 2.7
```

---

## 8. 정리

정리하면, 자바는 다음과 같은 순서로 메서드를 선택한다.

* 먼저 **전달된 인수의 타입과 정확히 맞는 메서드**를 찾는다.
* 그래도 없으면 **형변환이 가능한 타입의 메서드**를 찾아서 실행한다.
