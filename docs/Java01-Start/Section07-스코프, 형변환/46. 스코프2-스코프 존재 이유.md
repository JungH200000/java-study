# 스코프 2 — 스코프가 중요한 이유

> **핵심 한 줄 요약:** 변수의 **스코프(접근 범위)** 를 꼭 **필요한 곳으로 한정**하면, **메모리를 덜 쓰고** 코드가 **단순**해진다.

## 개념 정리

* **스코프(접근 범위)**: 변수를 **어디에서 접근할 수 있는지**를 결정하는 범위.
  스코프가 **넓으면** 더 오래·더 많은 곳에서 보이고, **좁으면** 필요한 곳에서만 보인다.

---

## 예제 1 — `temp`를 바깥(`main`)에 둘 때의 문제: `Scope3_1`

```java
package scope;

public class Scope3_1 {
    public static void main(String[] args) {
        int m = 10;      // 조건 비교 대상
        int temp = 0;    // 임시 변수(현재 선언 위치: main 블록 전체)

        if (m > 0) {     // 조건이 참일 때만 temp 사용
            temp = m * 2;
            System.out.println("temp = " + temp);
        }
        System.out.println("m = " + m);
    }
}
```

### 왜 좋지 않은가?

* **비효율적인 메모리 사용**: `temp`는 `if` 블록에서만 필요하지만 `main()` 끝날 때까지 **메모리에 유지**된다.
* **코드 복잡성 증가**: `if`가 끝난 뒤에도 `temp`가 **어디서나 보이므로**(스코프가 넓음) 유지보수 시 **불필요한 변수**를 계속 신경 써야 한다.

---

## 예제 2 — `temp`를 필요한 곳으로 한정: `Scope3_2`

```java
package scope;

public class Scope3_2 {
    public static void main(String[] args) {
        int m = 10;

        if (m > 0) {
            int temp = m * 2; // temp는 if 블록 안에서만 사용
            System.out.println("temp = " + temp);
        } // 여기서 temp 스코프 종료(제거)

        System.out.println("m = " + m);
    }
}
```

### 무엇이 좋아졌나?

* `temp`의 스코프를 **if 블록 내부로 축소** → 필요 시점이 끝나면 **빨리 제거**되어 **메모리 효율** 향상.
* 생각해야 할 변수가 **블록 내부로 한정** → 코드가 **단순**해지고 **유지보수성** 향상.

---

## while문 vs for문 — 스코프 관점 비교

### while: 카운터 변수 `i`의 스코프가 넓어짐

```java
package loop;

public class While2_3 {
    public static void main(String[] args) {
        int sum = 0;
        int i = 1;        // 카운터 변수 i: 스코프가 main 전체
        int endNum = 3;

        while (i <= endNum) {
            sum = sum + i;
            System.out.println("i=" + i + " sum=" + sum);
            i++;
        }

        //... 아래에 더 많은 코드들이 있다고 가정
    }
}
```

* `while`에서는 `i`를 **바깥에서 선언** → `main()` 전역에서 보이므로 **스코프가 넓다**.

### for: 카운터 변수 `i`의 스코프를 블록 내부로 제한

```java
package loop;

public class For2 {
    public static void main(String[] args) {
        int sum = 0;
        int endNum = 3;

        for (int i = 1; i <= endNum; i++) { // i의 스코프는 for 블록 내부
            sum = sum + i;
            System.out.println("i=" + i + " sum=" + sum);
        }

        //... 아래에 더 많은 코드들이 있다고 가정
    }
}
```

* `for`에서는 `i`를 **초기식에서 선언** → **반복 블록 안에서만** 보인다(스코프가 좁다).
* 따라서 `i`처럼 **for 안에서만 쓰는 카운터**는 `for`를 사용해 **스코프를 제한**하는 편이 **메모리/유지보수** 측면에서 유리하다.

---

## 정리

* 변수는 **꼭 필요한 범위**로 **스코프를 한정**하자.
  그래야 **메모리를 효율적으로 사용**하고, **더 단순한 코드**를 만들 수 있다.
* > 좋은 프로그램은 무한한 자유가 있는 프로그램이 아니라 **적절한 제약**이 있는 프로그램이다.
