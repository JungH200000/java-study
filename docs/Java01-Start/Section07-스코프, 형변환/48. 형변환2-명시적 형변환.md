# 형변환 2 — 명시적 형변환

> **한 줄 요약:** **큰 범위 → 작은 범위**로 대입할 때는 **명시적 형변환(캐스팅)** 이 필요하며, **값 손실**이나 **오버플로우**가 발생할 수 있다.

## 개념 정의

* **명시적 형변환(캐스팅)**: 대입하려는 **데이터 타입을 개발자가 직접 지정**해 강제로 변환하는 것. 예: `(int) someDouble`
* **이유**: `double → int`처럼 **표현 범위가 작은 타입**으로 대입하면 **정보 손실** 가능성이 있어 **컴파일 오류**가 발생한다. 이때 개발자가 **위험을 인지하고** `(타입)`을 붙여 **명시적으로 변환**해야 한다.

> 참고: **컴파일 오류**는 문제를 가장 빨리 발견할 수 있는 **좋은 오류**다.

---

## 예제 1 — `double → int`: 캐스팅 없이는 컴파일 오류 (`Casting2`)

### 코드

```java
package casting;

public class Casting2 {
    public static void main(String[] args) {
        double doubleValue = 1.5;
        int intValue = 0;

        // intValue = doubleValue; // 컴파일 오류 발생
        intValue = (int) doubleValue;   // 형변환(캐스팅)
        System.out.println(intValue);   // 출력: 1
    }
}
```

### 컴파일 오류 메시지(주석 해제 시)

```
java: incompatible types: possible lossy conversion from double to int
// java: 호환되지 않는 유형: double에서 int로의 가능한 손실 변환
```

### 왜 캐스팅이 필요한가?

* `double`은 **실수**(예: 1.5) 표현 가능, `int`는 **정수만** 표현.
* 그대로 대입하면 **소수점 버림** 등 **손실**이 생길 수 있어 **컴파일 오류**가 발생한다.
* 개발자가 **의도적으로** 소수점을 버리고 싶다면 **명시적 형변환**으로 위험을 **직접 감수**해야 한다.

### 캐스팅의 개념적 전개

```java
// doubleValue = 1.5
intValue = (int) doubleValue;
intValue = (int) 1.5;       // doubleValue에 있는 값을 읽는다.
intValue = 1;               // (int)로 형변환 한다. intValue에 1을 대입한다.
```

> **중요:** 캐스팅을 해도 **원본 변수의 타입/값은 바뀌지 않는다.**
> `doubleValue`는 여전히 `1.5`를 그대로 유지한다. 변수 값은 **대입 연산자(=)** 로 직접 대입할 때만 변경된다.

---

## 캐스팅 용어

* **Casting**은 영어 **cast**에서 유래: 금속 등을 녹여 **특정한 형태**로 만드는 과정 → **데이터를 다른 형태로 바꾼다**는 의미.

---

## 예제 2 — 형변환과 오버플로우 (`Casting3`)

### 코드

```java
package casting;

public class Casting3 {
    public static void main(String[] args) {
        long maxIntValue = 2147483647;   // int 최고값
        long maxIntOver  = 2147483648L;  // int 최고값 + 1(초과)
        int intValue = 0;

        intValue = (int) maxIntValue;    // 형변환
        System.out.println("maxIntValue casting=" + intValue); // 출력:2147483647

        intValue = (int) maxIntOver;     // 형변환
        System.out.println("maxIntOver  casting=" + intValue); // 출력:-2147483648
    }
}
```

### 실행 결과

```
maxIntValue casting=2147483647
maxIntOver  casting=-2147483648
```

### 정상 범위일 때(문제 없음)

* `2147483647`은 **int로 표현 가능한 최대값**이므로 `long → int` 캐스팅 시 문제 없음.

개념적 진행:

```java
maxIntValue = 2147483647;         // int 최고값
intValue = (int) maxIntValue;     // 변수 값 읽기
intValue = (int) 2147483647L;     // 형변환
intValue = 2147483647;
```

### 범위를 초과할 때(오버플로우)

* `2147483648L`은 **int 범위를 초과**. 캐스팅 시 **전혀 다른 값**이 나오는 **오버플로우** 발생.

개념적 진행:

```java
maxIntOver = 2147483648L;         // int 최고값 + 1
intValue   = (int) maxIntOver;    // 변수 값 읽기
intValue   = (int) 2147483648L;   // 형변환 시도
intValue   = -2147483648;         // 결과: int의 가장 작은 값
```

* 오버플로우는 **시계가 한 바퀴 도는 것처럼** 값이 처음으로 되돌아간 것처럼 보인다.
* **핵심:** 오버플로우가 **발생하는 것 자체가 문제**다. 결과를 계산하려 애쓰기보다 **애초에 발생하지 않도록** 해야 한다.
  → 이 경우 **대입 변수(`intValue`)의 타입을 `int`에서 `long`으로 변경**해 **사이즈를 늘리면** 문제를 피할 수 있다.
