# 클래스가 필요한 이유

자바에서는 프로그램의 세계가 **클래스와 객체**로 이루어져 있다고 볼 수 있다. 그만큼 클래스와 객체라는 개념은 중요하지만, 한 번에 이해하기에는 다루는 내용이 많다.

이 글에서는 **“클래스와 객체가 왜 필요한가?”** 라는 질문에서 출발해서,
지금까지 배운 **변수와 배열만으로 학생 정보를 다루는 방식**을 살펴보고,
그 한계를 통해 **클래스가 필요해지는 이유**까지 단계적으로 정리한다.

---

## 1. 문제: 학생 정보 출력 프로그램

먼저, 아래와 같은 문제를 해결한다고 가정해 보자.

> **문제: 학생 정보 출력 프로그램 만들기**
> 당신은 두 명의 학생 정보를 출력하는 프로그램을 작성해야 한다.
> 각 학생은 이름, 나이, 성적을 가지고 있다.

### 요구 사항

1. 첫 번째 학생의 이름은 `"학생1"`, 나이는 `15`, 성적은 `90`이다.
2. 두 번째 학생의 이름은 `"학생2"`, 나이는 `16`, 성적은 `80`이다.
3. 각 학생의 정보는 다음 형식으로 출력해야 한다.: `이름: [이름] 나이: [나이] 성적: [성적]`
4. 변수를 사용해서 학생 정보를 저장하고, 이 변수를 사용해서 학생 정보를 출력해야 한다.

### 예시 출력

```text
이름: 학생1 나이: 15 성적: 90
이름: 학생2 나이: 16 성적: 80
```

---

## 2. 변수만 사용한 풀이 – `ClassStart1`

먼저, **단순히 변수만**을 사용해서 문제를 해결한 예시이다.

### 코드: `class.ClassStart1`

```java
package class1;

public class ClassStart1 {
    public static void main(String[] args) {
        String student1Name = "학생1";
        int student1Age = 15;
        int student1Grade = 90;

        String student2Name = "학생2";
        int student2Age = 16;
        int student2Grade = 80;

        System.out.println("이름:" + student1Name + " 나이:" + student1Age + " 성 적:" + student1Grade);
        System.out.println("이름:" + student2Name + " 나이:" + student2Age + " 성 적:" + student2Grade);
    }
}
```

### 코드 설명

* 학생이 **2명**이기 때문에, 이름·나이·성적을 각각 별도의 변수로 선언했다.

    * 예) `student1Name`, `student1Age`, `student1Grade`
    * 예) `student2Name`, `student2Age`, `student2Grade`
* 각 학생 정보를 출력하기 위해 `System.out.println(...)`을 **학생마다 한 줄씩** 작성했다.
* 이 방식의 문제점:

    * 학생이 **늘어날 때마다** 이름, 나이, 성적에 대한 변수를 **새로 선언해야 한다.**
    * 출력 코드(`System.out.println(...)`)도 학생 수만큼 **계속 추가**해야 한다.

즉, 학생 수가 많아질수록 **코드 양이 기하급수적으로 늘어나고**,
수정·추가가 점점 더 번거로워진다.

---

## 3. 배열을 사용한 풀이 – `ClassStart2`

이 문제를 더 나은 방식으로 해결하기 위해,
앞에서 배운 **배열**을 활용해 보자.

> **목표:**
> 학생이 추가되더라도 **코드 변경(특히 출력 부분)을 최소화**하는 것이다.

### 코드: `class.ClassStart2`

```java
package class1;

public class ClassStart2 {
    public static void main(String[] args) {
        String[] studentNames = {"학생1", "학생2"};
        int[] studentAges = {15, 16};
        int[] studentGrades = {90, 80};

        for (int i = 0; i < studentNames.length; i++) {
            System.out.println("이름:" + studentNames[i] + " 나이:" + studentAges[i] + " 성적:" + studentGrades[i]);
        }
    }
}
```

### 코드 설명

* `studentNames`, `studentAges`, `studentGrades`

    * 각각 **이름, 나이, 성적을 담는 배열**이다.
    * 인덱스 `i`가 **같은 위치**라면, **같은 학생의 정보**를 의미한다.
* `for (int i = 0; i < studentNames.length; i++) { ... }`

    * `i`를 0부터 시작해서, 학생 수(`studentNames.length`)만큼 반복한다.
    * 반복문 안에서 인덱스 `i`를 사용해,

        * 이름: `studentNames[i]`
        * 나이: `studentAges[i]`
        * 성적: `studentGrades[i]`
          를 함께 출력한다.
* 이 방식의 장점:

    * 학생이 추가되면 **배열에 데이터만 추가**하면 되고,
    * **반복문 자체는 그대로 유지**할 수 있다.
      → 출력 코드를 학생 수만큼 따로 늘리지 않아도 된다.

---

## 4. 학생 추가 전/후 비교

배열을 사용하면, 학생이 늘어날 때 **배열의 데이터만 변경**하면 된다.

### 학생 추가 전

```java
String[] studentNames = {"학생1", "학생2"};
int[] studentAges = {15, 16};
int[] studentGrades = {90, 80};
```

### 학생 추가 후

```java
String[] studentNames = {"학생1", "학생2", "학생3", "학생4", "학생5"};
int[] studentAges = {15, 16, 17, 10, 16};
int[] studentGrades = {90, 80, 100, 80, 50};
```

* 새로운 학생이 생기면,

    * `studentNames`에 이름을 추가하고
    * `studentAges`에 나이를 추가하고
    * `studentGrades`에 성적을 추가하면 된다.
* **반복문 코드는 그대로** 사용 가능하다.
  → 이 점에서 배열은 변수만 사용할 때보다 훨씬 관리가 편하다.

하지만, 여기서도 **중요한 한계**가 드러난다.

---

## 5. 배열 사용의 한계

배열을 사용해도, 한 학생의 데이터가 **서로 다른 세 개의 배열**에 나뉘어 저장된다.

* 이름: `studentNames[]`
* 나이: `studentAges[]`
* 성적: `studentGrades[]`

따라서 다음과 같은 문제가 발생한다.

### 5.1. 한 학생의 데이터를 나눠서 관리

* 한 학생의 정보가 **3개의 배열에 분산**되어 있기 때문에,
  **항상 인덱스를 정확히 맞춰야 한다.**
* 예를 들어, **2번 학생의 데이터를 제거**하고 싶다고 해 보자.
  그러면 세 배열에서 모두 **2번 학생에 해당하는 요소를 정확히 제거**해야 한다.

### 학생2 제거 예시

```java
String[] studentNames = {"학생1", "학생3", "학생4", "학생5"};
int[] studentAges = {15, 17, 10, 16};
int[] studentGrades = {90, 100, 80, 50};
```

여기서 해야 할 작업:

* `studentNames`에서 `"학생2"`를 제거하고,
  나머지 학생들의 순서를 앞으로 당긴다.
* `studentAges`에서도 `"학생2"`에 해당하는 나이 `16`을 제거하고,
  마찬가지로 나머지 데이터를 당겨야 한다.
* `studentGrades`에서도 `"학생2"`의 성적 `80`을 제거한다.

이때 **세 배열의 인덱스가 모두 정확히 일치하도록** 수정해야 한다.

### 5.2. 사람에게는 실수하기 쉬운 코드

* 이 코드는 **컴퓨터 입장에서는 문제없이 동작**한다.
  (인덱스만 맞으면 되기 때문이다.)
* 하지만, **사람이 직접 관리하기에는 매우 위험한 구조**이다.

    * 배열 세 개를 동시에 수정해야 하고,
    * 하나라도 빠뜨리거나 인덱스를 잘못 맞추면 **데이터가 꼬인다.**
* 즉, **실수할 가능성이 매우 높고**,
  코드가 길어질수록 관리하기 어려워진다.

---

## 6. 정리: 사람이 관리하기 좋은 방식은?

지금까지처럼 이름, 나이, 성적을 **각각 따로 나눈 배열**로 관리하는 방식은
**사람이 관리하기에 좋은 방식이 아니다.**

사람이 관리하기 좋은 방식은 다음과 같다.

* **“학생”이라는 하나의 개념으로 묶어서**
  그 안에 이름, 나이, 성적을 함께 두는 것.
* 그리고 **각 학생마다 자기 자신의 이름, 나이, 성적**을 한 덩어리로 관리하는 것.

이렇게 하면,

* 한 학생의 정보를 **하나로 묶어서** 생각할 수 있고,
* 추가·수정·삭제할 때도 **실수할 가능성이 줄어든다.**

지금까지의 내용은, 이런 **“학생이라는 개념을 하나로 묶는 방식”**,
즉 앞으로 다루게 될 **클래스와 객체 개념이 왜 필요한지**를 이해하기 위한 준비 단계라고 볼 수 있다.
